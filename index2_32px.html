<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no" />
  <title>Floramancy</title>
  <style>
    @font-face {
      font-family: 'Alagard';
      src: url('fonts/Alagard.ttf') format('truetype');
      font-weight: normal;
      font-style: normal;
    }
    html, body { height: 100%; margin: 0; background:#000000; color:#e7e7e7; font-family: 'Alagard', monospace; overflow: hidden; -webkit-tap-highlight-color: transparent; }
    button, input, select, textarea { font-family: inherit; }
    body { display: flex; justify-content: center; align-items: center; }

    #game { display:block; image-rendering: pixelated; }

    /* Hamburger button */
    #hamburger { position: fixed; top: 10px; left: 10px; width: 44px; height: 44px; border-radius: 10px; border: 1px solid #3a3f46; background: rgba(0,0,0,.55); color:#e7e7e7; display: grid; place-items: center; cursor: pointer; z-index: 10; touch-action: manipulation; transition: opacity .3s; }
    #hamburger:focus { outline: 2px solid #79b; }
    #hamburger .bars { width: 22px; height: 16px; position: relative; }
    #hamburger .bars::before, #hamburger .bars::after, #hamburger .mid { content: ""; position: absolute; left: 0; right: 0; height: 2px; background: #e7e7e7; border-radius: 2px; }
    #hamburger .bars::before { top: 0; }
    #hamburger .mid { top: 7px; }
    #hamburger .bars::after { bottom: 0; }

    /* Turn indicator */
    #turnIndicator { position: fixed; top: 12px; right: 12px; display: flex; align-items: center; gap: 7px; padding: 6px 14px; border-radius: 20px; background: rgba(0,0,0,.55); border: 1px solid #3a3f46; font-size: 14px; font-weight: 600; z-index: 10; transition: opacity .3s; pointer-events: none; }
    #turnIndicator .dot { width: 10px; height: 10px; border-radius: 50%; flex-shrink: 0; }

    /* Fullscreen menu */
    #menu { position: fixed; inset: 0; background: rgba(0,0,0,.96); display: none; z-index: 20; overflow-y: auto; }
    #menu.open { display: grid; grid-template-rows: auto 1fr auto; }
    #menu header { padding: 16px 18px; display: flex; align-items: center; justify-content: space-between; border-bottom: 1px solid #2a2f36; }
    #menu header h1 { margin: 0; font-size: clamp(20px, 5vw, 28px); }
    #menu header button { padding: 10px 16px; border-radius: 8px; border: 1px solid #3a3f46; background:#0a0a0a; color:#e7e7e7; cursor:pointer; font-size: clamp(15px, 3.8vw, 19px); min-height: 48px; touch-action: manipulation; }
    #menu .content { padding: 20px 18px; display: grid; gap: 20px; align-content: start; }
    #menu .row { display: grid; gap: 12px; }
    #menu .row strong { font-size: clamp(17px, 4vw, 22px); }
    #menu .row ul { margin: 0; padding-left: 20px; }
    #menu .row li { font-size: clamp(15px, 3.8vw, 19px); line-height: 1.55; margin-bottom: 6px; }
    #menu .btns { display: flex; gap: 10px; flex-wrap: wrap; }
    #menu .btns button { font-size: clamp(16px, 4vw, 20px); padding: 10px 18px; min-height: 48px; border-radius: 8px; border: 1px solid #3a3f46; background:#0a0a0a; color:#e7e7e7; cursor:pointer; touch-action: manipulation; }
    #menu .sliders { display: grid; gap: 8px; }
    #menu .sliders label { display: flex; align-items: center; gap: 10px; font-size: clamp(14px, 3.5vw, 18px); }
    #menu .sliders input[type="range"] { flex: 1; accent-color: #5bb9ff; height: 6px; }
    #menu footer { padding: 14px 18px; border-top: 1px solid #2a2f36; display: flex; justify-content: space-between; align-items: center; }
    #menu footer small { font-size: clamp(13px, 3vw, 16px); }
    #menu footer a { text-decoration: none; }
    #menu footer a:hover { text-decoration: underline; }
    #menu header, #menu .content, #menu footer { max-width: 700px; width: 100%; margin-left: auto; margin-right: auto; box-sizing: border-box; }

    #meta { width: 120px; height: 120px; border: 1px solid #343a42; border-radius: 8px; background: #0a0a0a; }

    /* Splash screen */
    #splash { position: fixed; inset: 0; z-index: 50; background: #000000; display: flex; flex-direction: column; justify-content: center; align-items: center; gap: 18px; transition: opacity .5s; }
    #splash.hidden { opacity: 0; pointer-events: none; }
    #splash h1 { font-size: clamp(28px, 8vw, 52px); margin: 0; text-align: center; opacity: 0; animation: fadeUp .6s ease forwards; }
    #splash h1 .blue { color: #5bb9ff; }
    #splash h1 .yellow { color: #ffd240; }
    #splash .tagline { font-size: clamp(14px, 4vw, 20px); color: #8a8f98; margin: 0; opacity: 0; animation: fadeUp .6s ease .35s forwards; }
    #splash .playBtn { margin-top: 24px; padding: 14px 48px; font-size: clamp(18px, 5vw, 24px); font-weight: 700; border: 2px solid #5bb9ff; border-radius: 12px; background: transparent; color: #5bb9ff; cursor: pointer; opacity: 0; animation: fadeUp .6s ease .7s forwards; touch-action: manipulation; min-height: 48px; transition: background .2s, color .2s; }
    #splash .playBtn:hover, #splash .playBtn:active { background: #5bb9ff; color: #000000; }
    .mode-btns { display: flex; gap: 12px; justify-content: center; }

    @keyframes fadeUp {
      from { opacity: 0; transform: translateY(16px); }
      to { opacity: 1; transform: translateY(0); }
    }

    /* Win overlay */
    #winOverlay { position: fixed; inset: 0; z-index: 40; display: none; flex-direction: column; justify-content: center; align-items: center; }
    #winOverlay.show { display: flex; }
    #winOverlay canvas { position: absolute; inset: 0; width: 100%; height: 100%; }
    #winOverlay .msg { position: relative; z-index: 1; text-align: center; opacity: 0; transition: opacity .6s; }
    #winOverlay .msg.visible { opacity: 1; }
    #winOverlay .msg h2 { font-size: clamp(32px, 10vw, 64px); margin: 0 0 20px; font-weight: 800; }
    #winOverlay .msg button { padding: 14px 40px; font-size: clamp(18px, 5vw, 24px); font-weight: 700; border: 2px solid currentColor; border-radius: 12px; background: transparent; cursor: pointer; min-height: 48px; touch-action: manipulation; transition: background .2s, color .2s; }
  </style>
</head>
<body>
  <!-- Splash screen -->
  <div id="splash">
    <h1><span class="blue">Flora</span><span class="yellow">mancy</span></h1>
    <p class="tagline">A strategic twist on tic-tac-toe</p>
    <div class="mode-btns">
      <button class="playBtn" id="splash1P">1 Player</button>
      <button class="playBtn" id="splash2P">2 Player</button>
    </div>
  </div>

  <!-- Turn indicator -->
  <div id="turnIndicator" style="opacity:0;"><span class="dot"></span><span class="label">Blue's turn</span></div>

  <button id="hamburger" aria-label="Menu" title="Menu" style="opacity:0;"><span class="bars"><span class="mid"></span></span></button>
  <div id="menu" role="dialog" aria-modal="true" aria-labelledby="menuTitle">
    <header>
      <h1 id="menuTitle">Floramancy</h1>
      <button id="closeMenu">Close</button>
    </header>
    <div class="content">
      <div class="row">
        <strong>How to play</strong>
        <ul>
          <li>Tap a cell to plant your flower. Blue goes first.</li>
          <li>Tap the side arrows to slide a row or column. Wraparound. Sliding is a move.</li>
          <li>Each 3 by 3 mini board: the player with the most completed lines owns that tile.</li>
          <li>Get 3 owned tiles in a row on the big meta board to win.</li>
        </ul>
      </div>
      <div class="row">
        <strong>Game controls</strong>
        <div class="btns">
          <button id="resetBtn">Reset game</button>
          <button id="swapBtn">Swap starter</button>
          <button id="modeBtn">Mode: 2P</button>
        </div>
      </div>
      <div class="row">
        <strong>Slide cooldown</strong>
        <div class="sliders">
          <label>Forbidden slides <input type="range" id="slideCooldownSlider" min="0" max="18" value="2"> <span id="slideCooldownVal">2</span></label>
        </div>
      </div>
      <div class="row">
        <strong>Sound</strong>
        <div class="btns">
          <button id="musicToggle">Music: On</button>
          <button id="sfxToggle">SFX: On</button>
        </div>
        <div class="sliders">
          <label>Music <input type="range" id="musicVol" min="0" max="100" value="30"></label>
          <label>SFX <input type="range" id="sfxVol" min="0" max="100" value="80"></label>
        </div>
      </div>
      <div class="row">
        <strong>Meta board</strong>
        <canvas id="meta" aria-label="Meta board" role="img"></canvas>
      </div>
      <div class="row">
        <strong>Status</strong>
        <div id="status">-</div>
      </div>
    </div>
    <footer>
      <small>Tip: press H for menu. R resets.</small>
      <small>Music: <a href="https://unclehomunculus.bandcamp.com/album/unbecoming" target="_blank" rel="noopener" style="color:#5bb9ff;">unclehomunculus</a></small>
    </footer>
  </div>

  <div id="ytPlayer" style="position:absolute;width:1px;height:1px;overflow:hidden;pointer-events:none;"></div>
  <audio id="localMusic" loop preload="auto" style="display:none;"></audio>
  <canvas id="game" aria-label="Game board" role="img"></canvas>

  <!-- Win overlay -->
  <div id="winOverlay">
    <canvas id="winCanvas"></canvas>
    <div class="msg" id="winMsg">
      <h2 id="winText"></h2>
      <button id="winPlayAgain">Play Again</button>
    </div>
  </div>

  <script>
    // Board: 9x9 playable + arrow gutters that are the same size as cells.
    // Logical grid is 11x11: one cell gutter each side for arrows.

    const game = document.getElementById('game');
    const ctx = game.getContext('2d');

    const menu = document.getElementById('menu');
    const openBtn = document.getElementById('hamburger');
    const closeBtn = document.getElementById('closeMenu');

    const metaCanvas = document.getElementById('meta');
    const mctx = metaCanvas.getContext('2d');
    const statusEl = document.getElementById('status');
    const resetBtn = document.getElementById('resetBtn');
    const swapBtn = document.getElementById('swapBtn');

    // Splash & win elements
    const splashEl = document.getElementById('splash');
    const splash1PBtn = document.getElementById('splash1P');
    const splash2PBtn = document.getElementById('splash2P');
    const modeBtn = document.getElementById('modeBtn');
    const turnIndicator = document.getElementById('turnIndicator');
    const turnDot = turnIndicator.querySelector('.dot');
    const turnLabel = turnIndicator.querySelector('.label');
    const winOverlay = document.getElementById('winOverlay');
    const winCanvas = document.getElementById('winCanvas');
    const winCtx = winCanvas.getContext('2d');
    const winMsg = document.getElementById('winMsg');
    const winText = document.getElementById('winText');
    const winPlayAgain = document.getElementById('winPlayAgain');
    const musicToggle = document.getElementById('musicToggle');
    const sfxToggle = document.getElementById('sfxToggle');
    const musicVolEl = document.getElementById('musicVol');
    const sfxVolEl = document.getElementById('sfxVol');
    const localMusicEl = document.getElementById('localMusic');
    const slideCooldownSlider = document.getElementById('slideCooldownSlider');
    const slideCooldownVal = document.getElementById('slideCooldownVal');

    // ===== Sound System =====
    const Sound = (() => {
      let actx = null, sfxGain = null;
      let sfxOn = true, musicOn = true;
      let sfxVol = 0.8, musicVol = 30;
      let musicDucked = false;
      const buffers = {};
      const audioEls = {};
      const SFX = {
        place:        'sfx/place.mp3',
        slide:        'sfx/slide.mp3',
        capture:      'sfx/capture.mp3',
        multicapture: 'sfx/multicapture.mp3',
        win:          'sfx/win.mp3'
      };
      let gestureReceived = false;
      let onGestureQueue = null;

      const ls = k => { try { return localStorage.getItem(k); } catch(e) { return null; } };
      if (ls('sfxOn') === 'false') sfxOn = false;
      if (ls('musicOn') === 'false') musicOn = false;
      if (ls('sfxVol') !== null) sfxVol = +ls('sfxVol');
      if (ls('musicVol') !== null) musicVol = +ls('musicVol');

      function unlock() {
        if (gestureReceived) return;
        gestureReceived = true;
        try {
          actx = new (window.AudioContext || window.webkitAudioContext)();
          if (actx.state === 'suspended') actx.resume();
          sfxGain = actx.createGain();
          sfxGain.gain.value = sfxVol;
          sfxGain.connect(actx.destination);
          loadAll();
        } catch(e) { console.warn('[sound] AudioContext failed', e); }
        if (isLocal) {
          localMusicEl.src = 'sfx/music/bg.mp3';
          localMusicEl.volume = musicVol / 100;
          if (musicOn) localMusicEl.play().catch(() => {});
        } else {
          const s = document.createElement('script');
          s.src = 'https://www.youtube.com/iframe_api';
          document.body.appendChild(s);
          if (onGestureQueue) { onGestureQueue(); onGestureQueue = null; }
        }
      }

      async function loadAll() {
        for (const [name, path] of Object.entries(SFX)) {
          if (isLocal) {
            const a = new Audio(path);
            a.preload = 'auto';
            audioEls[name] = a;
          } else {
            try {
              const arr = await new Promise((resolve, reject) => {
                const xhr = new XMLHttpRequest();
                xhr.open('GET', path, true);
                xhr.responseType = 'arraybuffer';
                xhr.onload = () => (xhr.status === 200 || xhr.status === 0)
                  ? resolve(xhr.response) : reject(new Error(xhr.statusText));
                xhr.onerror = () => reject(new Error('XHR failed'));
                xhr.send();
              });
              buffers[name] = await actx.decodeAudioData(arr);
            } catch(e) { console.warn(`[sfx] failed: ${name}`, e); }
          }
        }
      }

      function play(name, opts = {}) {
        if (!sfxOn) return;
        if (isLocal) {
          const el = audioEls[name];
          if (!el) return;
          const clone = el.cloneNode();
          clone.volume = sfxVol;
          clone.play().catch(() => {});
          return;
        }
        if (!actx || !sfxGain || !buffers[name]) return;
        const src = actx.createBufferSource();
        src.buffer = buffers[name];
        src.playbackRate.value = opts.pitchVar ? 0.9 + Math.random() * 0.2 : 1.0;
        src.connect(sfxGain);
        src.start(0);
      }

      function setSfxVol(v) { sfxVol = v; if (sfxGain) sfxGain.gain.value = v; try { localStorage.setItem('sfxVol', v); } catch(e){} }

      function musicPlay() {
        if (isLocal) { localMusicEl.play().catch(() => {}); }
        else if (ytPlayer && ytReady) { ytPlayer.playVideo(); }
      }
      function musicPause() {
        if (isLocal) { localMusicEl.pause(); }
        else if (ytPlayer && ytReady) { ytPlayer.pauseVideo(); }
      }
      function musicSetVol(v) {
        if (isLocal) { localMusicEl.volume = v / 100; }
        else if (ytPlayer && ytReady) { ytPlayer.setVolume(v); }
      }

      function setMusicVol(v) {
        musicVol = v; try { localStorage.setItem('musicVol', v); } catch(e){}
        if (!musicDucked) musicSetVol(v);
      }

      function duckMusic() {
        if (!musicOn) return;
        musicDucked = true;
        musicSetVol(Math.round(musicVol * 0.1));
        setTimeout(() => { musicDucked = false; if (musicOn) musicSetVol(musicVol); }, 3000);
      }

      function toggleSfx() { sfxOn = !sfxOn; try { localStorage.setItem('sfxOn', sfxOn); } catch(e){} return sfxOn; }
      function toggleMusic() {
        musicOn = !musicOn;
        try { localStorage.setItem('musicOn', musicOn); } catch(e){}
        if (musicOn) { musicPlay(); } else { musicPause(); }
        if (!isLocal && musicOn && !ytPlayer && typeof YT !== 'undefined' && YT.Player) createYTPlayer();
        return musicOn;
      }

      return { unlock, play, setSfxVol, setMusicVol, duckMusic,
               toggleSfx, toggleMusic,
               isSfxOn: () => sfxOn, isMusicOn: () => musicOn,
               getSfxVol: () => sfxVol, getMusicVol: () => musicVol,
               get gestureReceived() { return gestureReceived; },
               set onGesture(fn) { onGestureQueue = fn; }
             };
    })();

    const isLocal = location.protocol === 'file:';

    // ===== YouTube IFrame API =====
    let ytPlayer = null, ytReady = false;

    function onYouTubeIframeAPIReady() {
      if (!Sound.gestureReceived) { Sound.onGesture = createYTPlayer; return; }
      createYTPlayer();
    }

    function createYTPlayer() {
      if (!Sound.isMusicOn()) return;
      ytPlayer = new YT.Player('ytPlayer', {
        height: '1', width: '1',
        playerVars: {
          listType: 'playlist',
          list: 'OLAK5uy_lziv66xux4fpp4gjWobjMUWkti8gYl9zQ',
          autoplay: 1, loop: 1, controls: 0, disablekb: 1, fs: 0,
          modestbranding: 1, rel: 0
        },
        events: {
          onReady: e => { ytReady = true; e.target.setShuffle(true); e.target.setVolume(Sound.getMusicVol()); if (Sound.isMusicOn()) e.target.playVideo(); },
          onError: e => console.warn('[music] YT error', e.data),
          onStateChange: e => { if (e.data === YT.PlayerState.ENDED) e.target.playVideo(); }
        }
      });
    }

    // Sync menu UI to stored prefs
    musicToggle.textContent = Sound.isMusicOn() ? 'Music: On' : 'Music: Off';
    sfxToggle.textContent = Sound.isSfxOn() ? 'SFX: On' : 'SFX: Off';
    musicVolEl.value = Sound.getMusicVol();
    sfxVolEl.value = Math.round(Sound.getSfxVol() * 100);

    const DPR = Math.max(1, Math.floor(window.devicePixelRatio || 1));

    // Grid sizes
    const GRID = 9;            // playable
    const GUTTER = 1;          // arrow gutter cells each side
    const TOTAL = GRID + GUTTER*2; // 11x11 logical

    // Logical cell size (in board coordinates). We keep this constant, and scale with CSS to fill viewport.
    const CELL = 30; // unit cell for internal math. Hit areas equal to cell by definition.

    // Origins
    const ORIGIN_X = GUTTER * CELL; // where the playable 9x9 starts inside the 11x11 board
    const ORIGIN_Y = GUTTER * CELL;

    // --- State ---
    const EMPTY = 0, P1 = 1, P2 = 2; // P1=blue, P2=yellow
    let board, current, winner, moveCount;
    let splashActive = true;
    let gameMode = +(localStorage.getItem('gameMode') || 2); // 1 = vs AI, 2 = local 2P

    // Slide cooldown state
    let slideCooldown = +(localStorage.getItem('slideCooldown') ?? 2);
    let slideHistory = []; // FIFO of { kind:'row'|'col', idx:0-8 }

    function isSlideForbidden(kind, idx) {
      return slideHistory.some(h => h.kind === kind && h.idx === idx);
    }

    // Animation state
    let anim = null; // { kind:'row'|'col', idx:number, dir:-1|+1, t:0..1, start:number, dur:number, pre:Array, post:Array }

    // Per-mini-board fade state: alpha per owner. Fades in on capture, fades out on loss or neutral.
    const blockFade = Array.from({length:3}, () => Array.from({length:3}, () => ({ a1:0, a2:0 })));
    const FADE_SPEED = 6; // per second, ~0->1 in ~166ms
    const prevOwnership = Array.from({length:3}, () => Array(3).fill(EMPTY));
    let prevLines = new Set();

    // --- Procedural visuals ---
    const PROCEDURAL_FLOWERS = true;
    const flowerState = new Map();
    const grassState = new Map();
    const SPRING_K = 150;
    const SPRING_DAMP = 10;
    const SPRING_IMPULSE = 8;
    const SHOW_WALKERS = false;
    const walkers = [];
    const arrowSpring = new Map(); // key: "cx,cy" → { scale, vel }

    // Global RAF loop time
    let lastTime = 0;

    // --- Splash screen ---
    splash1PBtn.addEventListener('click', () => { gameMode = 1; try { localStorage.setItem('gameMode', 1); } catch(e){} updateModeBtn(); dismissSplash(); });
    splash2PBtn.addEventListener('click', () => { gameMode = 2; try { localStorage.setItem('gameMode', 2); } catch(e){} updateModeBtn(); dismissSplash(); });
    function updateModeBtn() { modeBtn.textContent = 'Mode: ' + (gameMode === 1 ? '1P' : '2P'); }

    function dismissSplash(){
      if (!splashActive) return;
      splashActive = false;
      Sound.unlock();
      splashEl.classList.add('hidden');
      openBtn.style.opacity = '1';
      turnIndicator.style.opacity = '1';
      setTimeout(() => { splashEl.style.display = 'none'; }, 600);
    }

    function reset(){
      board = Array.from({length: GRID}, () => Array(GRID).fill(EMPTY));
      current = P1; winner = 0; moveCount = 0; anim = null; slideHistory = [];
      flowerState.clear(); grassState.clear(); walkers.length = 0;
      // reset fades
      for (let by=0; by<3; by++) for (let bx=0; bx<3; bx++){ blockFade[by][bx].a1 = 0; blockFade[by][bx].a2 = 0; }
      for (let by=0;by<3;by++) for (let bx=0;bx<3;bx++) prevOwnership[by][bx] = EMPTY;
      prevLines = new Set();
      hideWinOverlay();
      updateStatus();
      draw(); drawMetaPreview();
    }

    function swapStarter(){ current = current === P1 ? P2 : P1; updateStatus(); }

    resetBtn.addEventListener('click', () => { reset(); });
    swapBtn.addEventListener('click', () => { swapStarter(); });
    modeBtn.addEventListener('click', () => { gameMode = gameMode === 1 ? 2 : 1; try { localStorage.setItem('gameMode', gameMode); } catch(e){} updateModeBtn(); reset(); });
    updateModeBtn();
    musicToggle.addEventListener('click', () => { const on = Sound.toggleMusic(); musicToggle.textContent = on ? 'Music: On' : 'Music: Off'; });
    sfxToggle.addEventListener('click', () => { const on = Sound.toggleSfx(); sfxToggle.textContent = on ? 'SFX: On' : 'SFX: Off'; });
    musicVolEl.addEventListener('input', () => Sound.setMusicVol(+musicVolEl.value));
    sfxVolEl.addEventListener('input', () => Sound.setSfxVol(+sfxVolEl.value / 100));
    slideCooldownSlider.value = slideCooldown;
    slideCooldownVal.textContent = slideCooldown;
    slideCooldownSlider.addEventListener('input', () => {
      slideCooldown = +slideCooldownSlider.value;
      slideCooldownVal.textContent = slideCooldown;
      try { localStorage.setItem('slideCooldown', slideCooldown); } catch(e){}
      while (slideHistory.length > slideCooldown) slideHistory.shift();
    });

    // Resize: scale canvas to exact pixel size of logical board scaled to fit viewport while keeping square aspect.
    function resize(){
      const logicalW = TOTAL * CELL;
      const logicalH = TOTAL * CELL;
      const scale = Math.min(innerWidth / logicalW, innerHeight / logicalH);
      const cssW = Math.floor(logicalW * scale);
      const cssH = Math.floor(logicalH * scale);

      // Canvas internal pixels use DPR for crispness
      game.width = Math.floor(logicalW * DPR);
      game.height = Math.floor(logicalH * DPR);
      game.style.width = cssW + 'px';
      game.style.height = cssH + 'px';
      ctx.setTransform(DPR, 0, 0, DPR, 0, 0);
      ctx.imageSmoothingEnabled = false;

      // Meta preview DPI
      const metaSize = Math.min(140, Math.floor(Math.min(innerWidth, innerHeight) * 0.22));
      metaCanvas.style.width = metaSize + 'px';
      metaCanvas.style.height = metaSize + 'px';
      metaCanvas.width = metaSize * DPR; metaCanvas.height = metaSize * DPR;
      mctx.setTransform(DPR, 0, 0, DPR, 0, 0);

      // Win canvas
      winCanvas.width = innerWidth * DPR;
      winCanvas.height = innerHeight * DPR;
      winCanvas.style.width = innerWidth + 'px';
      winCanvas.style.height = innerHeight + 'px';
      winCtx.setTransform(DPR, 0, 0, DPR, 0, 0);

      draw(); drawMetaPreview();
    }

    addEventListener('resize', () => setTimeout(resize, 0));

    function updateStatus(){
      const text = winner ? (winner === P1 ? 'Blue wins' : 'Yellow wins') : ('Turn: ' + (current === P1 ? 'Blue' : 'Yellow') + ' • Moves: ' + moveCount + (anim? ' • Sliding…' : ''));
      statusEl.textContent = text;

      // Update turn indicator
      if (winner || splashActive) {
        turnIndicator.style.opacity = '0';
      } else {
        turnIndicator.style.opacity = '1';
        const isBlue = current === P1;
        turnDot.style.background = isBlue ? '#5bb9ff' : '#ffd240';
        turnLabel.textContent = isBlue ? "Blue's turn" : "Yellow's turn";
      }
    }

    function other(p){ return p === P1 ? P2 : P1; }

    // Hit detection
    function toLocal(e){
      const rect = game.getBoundingClientRect();
      const mx = (e.clientX - rect.left) * (game.width / rect.width) / DPR;
      const my = (e.clientY - rect.top) * (game.height / rect.height) / DPR;
      return {mx, my};
    }

    function localToCell(mx, my){
      const cx = Math.floor(mx / CELL);
      const cy = Math.floor(my / CELL);
      if (cx < 0 || cx >= TOTAL || cy < 0 || cy >= TOTAL) return null;
      return {cx, cy};
    }

    // Arrow rects are full cell squares in the gutters
    function isArrowCell(cx, cy){
      if (anim) return null; // block during animation
      let result = null;
      if (cx === 0 && cy >= GUTTER && cy < GUTTER + GRID) result = {type:'row-left', idx: cy - GUTTER};
      else if (cx === TOTAL-1 && cy >= GUTTER && cy < GUTTER + GRID) result = {type:'row-right', idx: cy - GUTTER};
      else if (cy === 0 && cx >= GUTTER && cx < GUTTER + GRID) result = {type:'col-up', idx: cx - GUTTER};
      else if (cy === TOTAL-1 && cx >= GUTTER && cx < GUTTER + GRID) result = {type:'col-down', idx: cx - GUTTER};
      if (!result) return null;
      const kind = result.type.startsWith('row') ? 'row' : 'col';
      if (isSlideForbidden(kind, result.idx)) return null;
      return result;
    }

    // --- Ownership helpers with bounds safety ---
    function smallOwnerFrom(b, bx, by){
      if (!b || b.length !== GRID || b.some(row => !Array.isArray(row) || row.length !== GRID)) return EMPTY;
      if (bx < 0 || bx > 2 || by < 0 || by > 2) return EMPTY;
      const sx = bx * 3; const sy = by * 3; let c1=0, c2=0;
      for (let r = 0; r < 3; r++){
        const row = b[sy + r]; const line = [row[sx], row[sx+1], row[sx+2]];
        if (line.every(v => v === P1)) c1++; if (line.every(v => v === P2)) c2++;
      }
      for (let c = 0; c < 3; c++){
        const line = [b[sy][sx+c], b[sy+1][sx+c], b[sy+2][sx+c]];
        if (line.every(v => v === P1)) c1++; if (line.every(v => v === P2)) c2++;
      }
      const d1 = [b[sy][sx], b[sy+1][sx+1], b[sy+2][sx+2]];
      const d2 = [b[sy][sx+2], b[sy+1][sx+1], b[sy+2][sx]];
      if (d1.every(v => v === P1)) c1++; if (d1.every(v => v === P2)) c2++;
      if (d2.every(v => v === P1)) c1++; if (d2.every(v => v === P2)) c2++;
      if (c1>c2) return P1; if (c2>c1) return P2; return EMPTY;
    }
    function smallOwner(bx, by){ return smallOwnerFrom(board, bx, by); }

    function metaWinnerFrom(b){
      const M = Array.from({length:3}, () => Array(3).fill(EMPTY));
      for (let by = 0; by < 3; by++) for (let bx = 0; bx < 3; bx++) M[by][bx] = smallOwnerFrom(b, bx, by);
      const lines = [];
      for (let r=0;r<3;r++) lines.push([M[r][0],M[r][1],M[r][2]]);
      for (let c=0;c<3;c++) lines.push([M[0][c],M[1][c],M[2][c]]);
      lines.push([M[0][0],M[1][1],M[2][2]]);
      lines.push([M[0][2],M[1][1],M[2][0]]);
      if (lines.some(l => l.every(v => v===P1))) return P1;
      if (lines.some(l => l.every(v => v===P2))) return P2;
      return EMPTY;
    }
    function metaWinner(){ return metaWinnerFrom(board); }

    // --- Win check ---
    function checkForWin(){
      if (!winner) return;
      setTimeout(() => showWinOverlay(winner), 400);
    }

    function completedLineSet() {
      const set = new Set();
      for (let by = 0; by < 3; by++) {
        for (let bx = 0; bx < 3; bx++) {
          const sx = bx * 3, sy = by * 3, base = (by * 3 + bx) * 8;
          // rows
          for (let r = 0; r < 3; r++) {
            const line = [board[sy+r][sx], board[sy+r][sx+1], board[sy+r][sx+2]];
            if (line[0] !== EMPTY && line.every(v => v === line[0])) set.add(base + r);
          }
          // cols
          for (let c = 0; c < 3; c++) {
            const line = [board[sy][sx+c], board[sy+1][sx+c], board[sy+2][sx+c]];
            if (line[0] !== EMPTY && line.every(v => v === line[0])) set.add(base + 3 + c);
          }
          // diags
          const d1 = [board[sy][sx], board[sy+1][sx+1], board[sy+2][sx+2]];
          if (d1[0] !== EMPTY && d1.every(v => v === d1[0])) set.add(base + 6);
          const d2 = [board[sy][sx+2], board[sy+1][sx+1], board[sy+2][sx]];
          if (d2[0] !== EMPTY && d2.every(v => v === d2[0])) set.add(base + 7);
        }
      }
      return set;
    }

    function checkOwnershipChanges() {
      // Update prevOwnership (used by reset)
      for (let by = 0; by < 3; by++)
        for (let bx = 0; bx < 3; bx++)
          prevOwnership[by][bx] = smallOwner(bx, by);
      // Count new completed lines
      const curLines = completedLineSet();
      let newCount = 0;
      for (const k of curLines) if (!prevLines.has(k)) newCount++;
      prevLines = curLines;
      if (newCount >= 2) Sound.play('multicapture');
      else if (newCount === 1) Sound.play('capture');
    }

    // --- AI (Minimax, 2-ply) ---
    function lineCountFrom(b, bx, by, player) {
      const sx = bx * 3, sy = by * 3; let count = 0;
      for (let r = 0; r < 3; r++) if ([b[sy+r][sx], b[sy+r][sx+1], b[sy+r][sx+2]].every(v => v === player)) count++;
      for (let c = 0; c < 3; c++) if ([b[sy][sx+c], b[sy+1][sx+c], b[sy+2][sx+c]].every(v => v === player)) count++;
      if ([b[sy][sx], b[sy+1][sx+1], b[sy+2][sx+2]].every(v => v === player)) count++;
      if ([b[sy][sx+2], b[sy+1][sx+1], b[sy+2][sx]].every(v => v === player)) count++;
      return count;
    }

    function evaluateBoard(b) {
      const mw = metaWinnerFrom(b);
      if (mw === P2) return 10000;
      if (mw === P1) return -10000;
      let score = 0;
      // Meta-board analysis
      const M = Array.from({length:3}, () => Array(3).fill(EMPTY));
      for (let by = 0; by < 3; by++) for (let bx = 0; bx < 3; bx++) M[by][bx] = smallOwnerFrom(b, bx, by);
      // Meta lines
      const metaLines = [];
      for (let r = 0; r < 3; r++) metaLines.push([M[r][0], M[r][1], M[r][2]]);
      for (let c = 0; c < 3; c++) metaLines.push([M[0][c], M[1][c], M[2][c]]);
      metaLines.push([M[0][0], M[1][1], M[2][2]]);
      metaLines.push([M[0][2], M[1][1], M[2][0]]);
      for (const line of metaLines) {
        const p2c = line.filter(v => v === P2).length;
        const p1c = line.filter(v => v === P1).length;
        if (p2c === 2 && p1c === 0) score += 500;
        if (p1c === 2 && p2c === 0) score -= 500;
      }
      // Board ownership + line count
      for (let by = 0; by < 3; by++) {
        for (let bx = 0; bx < 3; bx++) {
          if (M[by][bx] === P2) score += 100;
          else if (M[by][bx] === P1) score -= 100;
          score += (lineCountFrom(b, bx, by, P2) - lineCountFrom(b, bx, by, P1)) * 10;
        }
      }
      return score;
    }

    function getAllMoves(b) {
      const moves = [];
      for (let y = 0; y < GRID; y++)
        for (let x = 0; x < GRID; x++)
          if (b[y][x] === EMPTY) moves.push({ type: 'place', x, y });
      for (let r = 0; r < GRID; r++) {
        if (!isSlideForbidden('row', r)) {
          moves.push({ type: 'row', idx: r, dir: -1 });
          moves.push({ type: 'row', idx: r, dir: 1 });
        }
      }
      for (let c = 0; c < GRID; c++) {
        if (!isSlideForbidden('col', c)) {
          moves.push({ type: 'col', idx: c, dir: -1 });
          moves.push({ type: 'col', idx: c, dir: 1 });
        }
      }
      return moves;
    }

    function applyMove(b, move, player) {
      const nb = b.map(r => r.slice());
      if (move.type === 'place') {
        nb[move.y][move.x] = player;
      } else if (move.type === 'row') {
        const row = nb[move.idx].slice();
        if (move.dir === -1) { const f = row[0]; for (let c = 0; c < GRID-1; c++) row[c] = row[c+1]; row[GRID-1] = f; }
        else { const l = row[GRID-1]; for (let c = GRID-1; c > 0; c--) row[c] = row[c-1]; row[0] = l; }
        nb[move.idx] = row;
      } else {
        const col = nb.map(r => r[move.idx]);
        if (move.dir === -1) { const f = col[0]; for (let r = 0; r < GRID-1; r++) col[r] = col[r+1]; col[GRID-1] = f; }
        else { const l = col[GRID-1]; for (let r = GRID-1; r > 0; r--) col[r] = col[r-1]; col[0] = l; }
        for (let r = 0; r < GRID; r++) nb[r][move.idx] = col[r];
      }
      return nb;
    }

    function minimax(b, depth, alpha, beta, maximizing) {
      const mw = metaWinnerFrom(b);
      if (mw === P2) return 10000;
      if (mw === P1) return -10000;
      if (depth === 0) return evaluateBoard(b);
      const player = maximizing ? P2 : P1;
      const moves = getAllMoves(b);
      if (maximizing) {
        let best = -Infinity;
        for (const m of moves) {
          const nb = applyMove(b, m, player);
          const val = minimax(nb, depth - 1, alpha, beta, false);
          best = Math.max(best, val);
          alpha = Math.max(alpha, val);
          if (beta <= alpha) break;
        }
        return best;
      } else {
        let best = Infinity;
        for (const m of moves) {
          const nb = applyMove(b, m, player);
          const val = minimax(nb, depth - 1, alpha, beta, true);
          best = Math.min(best, val);
          beta = Math.min(beta, val);
          if (beta <= alpha) break;
        }
        return best;
      }
    }

    function aiMove() {
      if (gameMode !== 1 || current !== P2 || winner) return;
      const moves = getAllMoves(board);
      let bestVal = -Infinity, bestMove = moves[0];
      for (const m of moves) {
        const nb = applyMove(board, m, P2);
        const val = minimax(nb, 1, -Infinity, Infinity, false); // depth 1 remaining = 2-ply total
        if (val > bestVal) { bestVal = val; bestMove = m; }
      }
      if (!bestMove) return;
      if (bestMove.type === 'place') {
        board[bestMove.y][bestMove.x] = P2;
        Sound.play('place', { pitchVar: true });
        ensureFlowerState(bestMove.x, bestMove.y, P2);
        moveCount++; current = other(current); winner = metaWinner(); updateStatus();
        checkOwnershipChanges();
        checkForWin();
        draw(); drawMetaPreview();
      } else if (bestMove.type === 'row') {
        startRowSlide(bestMove.idx, bestMove.dir);
      } else {
        startColSlide(bestMove.idx, bestMove.dir);
      }
    }

    function scheduleAI() {
      if (gameMode === 1 && current === P2 && !winner) setTimeout(aiMove, 500);
    }

    // --- Animation helpers ---
    function startRowSlide(r, dir){
      if (anim) return;
      const pre = board[r].slice();
      const post = pre.slice();
      if (dir === -1){ const first = post[0]; for (let c=0;c<GRID-1;c++) post[c]=post[c+1]; post[GRID-1]=first; }
      else { const last = post[GRID-1]; for (let c=GRID-1;c>0;c--) post[c]=post[c-1]; post[0]=last; }
      anim = { kind:'row', idx:r, dir, t:0, start:performance.now(), dur:180, pre, post };
      Sound.play('slide');
      applySlideImpulse('row', r, dir);
      updateStatus();
    }

    function startColSlide(c, dir){
      if (anim) return;
      const pre = board.map(row=>row[c]);
      const post = pre.slice();
      if (dir === -1){ const first = post[0]; for (let r=0;r<GRID-1;r++) post[r]=post[r+1]; post[GRID-1]=first; }
      else { const last = post[GRID-1]; for (let r=GRID-1;r>0;r--) post[r]=post[r-1]; post[0]=last; }
      anim = { kind:'col', idx:c, dir, t:0, start:performance.now(), dur:180, pre, post };
      Sound.play('slide');
      applySlideImpulse('col', c, dir);
      updateStatus();
    }

    function commitAnim(){
      if (!anim) return;
      if (anim.kind === 'row'){
        board[anim.idx] = anim.post;
      } else {
        for (let r=0;r<GRID;r++) board[r][anim.idx] = anim.post[r];
      }
      remapFlowerKeys(anim.kind, anim.idx, anim.dir);
      remapGrassKeys(anim.kind, anim.idx, anim.dir);
      slideHistory.push({ kind: anim.kind, idx: anim.idx });
      while (slideHistory.length > slideCooldown) slideHistory.shift();
      anim = null;
      moveCount++; current = other(current); winner = metaWinner(); updateStatus();
      checkOwnershipChanges();
      checkForWin();
      draw(); drawMetaPreview();
      scheduleAI();
    }

    // Per-frame update
    function step(dt){
      // fade mini-board ownership
      for (let by=0; by<3; by++){
        for (let bx=0; bx<3; bx++){
          const owner = smallOwner(bx, by);
          const target1 = owner===P1 ? 1 : 0;
          const target2 = owner===P2 ? 1 : 0;
          const f = blockFade[by][bx];
          // approach function
          const stepToward = (a, t) => {
            if (a === t) return a;
            const dir = t > a ? 1 : -1;
            let next = a + dir * FADE_SPEED * dt;
            if ((dir>0 && next>t) || (dir<0 && next<t)) next = t;
            return next;
          };
          f.a1 = stepToward(f.a1, target1);
          f.a2 = stepToward(f.a2, target2);
        }
      }

      // Procedural updates
      updateFlowerSprings(dt);
      updateArrowSprings(dt);
      updateWalkers(dt);

      // slide animation
      if (anim){
        const elapsed = (performance.now() - anim.start);
        anim.t = Math.min(1, elapsed / anim.dur);
        if (anim.t >= 1) commitAnim();
      }
    }

    // Master RAF
    function frame(now){
      if (!lastTime) lastTime = now;
      const dt = Math.min(0.1, (now - lastTime) / 1000);
      lastTime = now;
      step(dt);
      draw();
      if (winAnimRunning) drawWinFrame(dt);
      requestAnimationFrame(frame);
    }

    // Input
    game.addEventListener('click', e => {
      if (!board || winner) return;
      if (gameMode === 1 && current === P2) return; // AI's turn
      const {mx, my} = toLocal(e);
      const cell = localToCell(mx, my); if (!cell) return;
      if (anim) return; // ignore during animation

      // Arrow? then slide animated
      const arrow = isArrowCell(cell.cx, cell.cy);
      if (arrow){
        if (arrow.type === 'row-left') startRowSlide(arrow.idx, -1);
        if (arrow.type === 'row-right') startRowSlide(arrow.idx, +1);
        if (arrow.type === 'col-up') startColSlide(arrow.idx, -1);
        if (arrow.type === 'col-down') startColSlide(arrow.idx, +1);
        return;
      }

      // Playable cell?
      if (cell.cx >= GUTTER && cell.cx < GUTTER + GRID && cell.cy >= GUTTER && cell.cy < GUTTER + GRID){
        const gx = cell.cx - GUTTER; const gy = cell.cy - GUTTER;
        if (board[gy][gx] === EMPTY){
          board[gy][gx] = current;
          Sound.play('place', { pitchVar: true });
          ensureFlowerState(gx, gy, current);
          if (SHOW_WALKERS) spawnWalker(current, gx, gy);
          moveCount++; current = other(current); winner = metaWinner(); updateStatus();
          checkOwnershipChanges();
          checkForWin();
          draw(); drawMetaPreview();
          scheduleAI();
        }
      }
    });

    let hoveredArrow = null; // { cx, cy, type } or null
    game.addEventListener('pointermove', e => {
      const {mx, my} = toLocal(e);
      const cell = localToCell(mx, my);
      if (cell) {
        const arrow = isArrowCell(cell.cx, cell.cy);
        hoveredArrow = arrow ? { cx: cell.cx, cy: cell.cy, type: arrow.type } : null;
      } else { hoveredArrow = null; }
    });
    game.addEventListener('pointerleave', () => { hoveredArrow = null; });

    addEventListener('keydown', e => {
      const k = e.key.toLowerCase();
      if (k === 'r'){ reset(); }
      if (k === 'h' || k === '?') toggleMenu(true);
      if (k === 'escape') toggleMenu(false);
    });

    function slideRow(r, dir){ /* kept for tests; not used in UI now */
      if (dir === -1){ const first = board[r][0]; for (let c=0;c<GRID-1;c++) board[r][c] = board[r][c+1]; board[r][GRID-1] = first; }
      else { const last = board[r][GRID-1]; for (let c=GRID-1;c>0;c--) board[r][c] = board[r][c-1]; board[r][0] = last; }
    }
    function slideCol(c, dir){ /* kept for tests */
      if (dir === -1){ const first = board[0][c]; for (let r=0;r<GRID-1;r++) board[r][c] = board[r+1][c]; board[GRID-1][c] = first; }
      else { const last = board[GRID-1][c]; for (let r=GRID-1;r>0;r--) board[r][c] = board[r-1][c]; board[0][c] = last; }
    }

    // --- Procedural flower helpers ---
    function ensureFlowerState(gx, gy, owner) {
      const key = gx + ',' + gy;
      if (!flowerState.has(key)) {
        const type = flowerHash(gx, gy) % 5;
        flowerState.set(key, { owner, phase: Math.random() * Math.PI * 2, springDisp: 0, springVel: 0, type });
      }
      const s = flowerState.get(key);
      s.owner = owner;
      return s;
    }

    function applySlideImpulse(kind, idx, dir) {
      for (let y = 0; y < GRID; y++) {
        for (let x = 0; x < GRID; x++) {
          const key = x + ',' + y;
          const s = flowerState.get(key);
          if (!s) continue;
          const dist = kind === 'row' ? Math.abs(y - idx) : Math.abs(x - idx);
          const scale = dist === 0 ? 1.0 : dist === 1 ? 0.6 : dist === 2 ? 0.3 : 0;
          if (scale > 0) s.springVel -= dir * SPRING_IMPULSE * scale;
        }
      }
    }

    function remapFlowerKeys(kind, idx, dir) {
      if (kind === 'row') {
        const row = [];
        for (let x = 0; x < GRID; x++) { const k = x + ',' + idx; row.push(flowerState.get(k) || null); flowerState.delete(k); }
        const shifted = new Array(GRID);
        for (let x = 0; x < GRID; x++) shifted[x] = row[((x - dir) % GRID + GRID) % GRID];
        for (let x = 0; x < GRID; x++) { if (shifted[x]) flowerState.set(x + ',' + idx, shifted[x]); }
      } else {
        const col = [];
        for (let y = 0; y < GRID; y++) { const k = idx + ',' + y; col.push(flowerState.get(k) || null); flowerState.delete(k); }
        const shifted = new Array(GRID);
        for (let y = 0; y < GRID; y++) shifted[y] = col[((y - dir) % GRID + GRID) % GRID];
        for (let y = 0; y < GRID; y++) { if (shifted[y]) flowerState.set(idx + ',' + y, shifted[y]); }
      }
    }

    function ensureGrassState(x, y) {
      const k = x + ',' + y;
      if (!grassState.has(k)) grassState.set(k, ((x * 73856093) ^ (y * 19349663)) >>> 0);
      return grassState.get(k);
    }

    function remapGrassKeys(kind, idx, dir) {
      if (kind === 'row') {
        const row = [];
        for (let x = 0; x < GRID; x++) { const k = x + ',' + idx; row.push(grassState.get(k) || null); grassState.delete(k); }
        const shifted = new Array(GRID);
        for (let x = 0; x < GRID; x++) shifted[x] = row[((x - dir) % GRID + GRID) % GRID];
        for (let x = 0; x < GRID; x++) { if (shifted[x] !== null) grassState.set(x + ',' + idx, shifted[x]); }
      } else {
        const col = [];
        for (let y = 0; y < GRID; y++) { const k = idx + ',' + y; col.push(grassState.get(k) || null); grassState.delete(k); }
        const shifted = new Array(GRID);
        for (let y = 0; y < GRID; y++) shifted[y] = col[((y - dir) % GRID + GRID) % GRID];
        for (let y = 0; y < GRID; y++) { if (shifted[y] !== null) grassState.set(idx + ',' + y, shifted[y]); }
      }
    }

    function updateFlowerSprings(dt) {
      for (const [, s] of flowerState) {
        s.springVel += (-SPRING_K * s.springDisp - SPRING_DAMP * s.springVel) * dt;
        s.springDisp += s.springVel * dt;
        if (Math.abs(s.springDisp) < 0.0001 && Math.abs(s.springVel) < 0.0001) { s.springDisp = 0; s.springVel = 0; }
      }
    }

    function ensureArrowSpring(cx, cy) {
      const k = cx + ',' + cy;
      if (!arrowSpring.has(k)) arrowSpring.set(k, { scale: 0.5, vel: 0 });
      return arrowSpring.get(k);
    }

    function updateArrowSprings(dt) {
      for (const [k, s] of arrowSpring) {
        const [cx, cy] = k.split(',').map(Number);
        const hovered = hoveredArrow && hoveredArrow.cx === cx && hoveredArrow.cy === cy;
        const target = hovered ? 1.0 : 0.5;
        const ARROW_K = 200, ARROW_D = 14;
        s.vel += (-ARROW_K * (s.scale - target) - ARROW_D * s.vel) * dt;
        s.scale += s.vel * dt;
        if (Math.abs(s.scale - target) < 0.001 && Math.abs(s.vel) < 0.01) { s.scale = target; s.vel = 0; }
      }
    }

    // --- Autotile edge helpers ---
    function getNeighborMask(x, y) {
      const owner = board[y][x];
      if (!owner) return 0;
      let mask = 0;
      if (y > 0 && board[y-1][x] === owner) mask |= 1;
      if (x < GRID-1 && board[y][x+1] === owner) mask |= 2;
      if (y < GRID-1 && board[y+1][x] === owner) mask |= 4;
      if (x > 0 && board[y][x-1] === owner) mask |= 8;
      return mask;
    }

    function drawAutotileEdges(x, y) {
      const owner = board[y][x];
      if (!owner) return;
      const mask = getNeighborMask(x, y);
      const left = ORIGIN_X + x * CELL;
      const top = ORIGIN_Y + y * CELL;
      const rgb = owner === P1 ? '91,185,255' : '255,210,64';
      // Connected sides: subtle owner-color strip; unconnected: dark edge
      if (mask & 1) { ctx.fillStyle = `rgba(${rgb},0.1)`; ctx.fillRect(left, top, CELL, 2); }
      else { ctx.fillStyle = 'rgba(0,0,0,0.3)'; ctx.fillRect(left, top, CELL, 1); }
      if (mask & 2) { ctx.fillStyle = `rgba(${rgb},0.1)`; ctx.fillRect(left + CELL - 2, top, 2, CELL); }
      else { ctx.fillStyle = 'rgba(0,0,0,0.3)'; ctx.fillRect(left + CELL - 1, top, 1, CELL); }
      if (mask & 4) { ctx.fillStyle = `rgba(${rgb},0.1)`; ctx.fillRect(left, top + CELL - 2, CELL, 2); }
      else { ctx.fillStyle = 'rgba(0,0,0,0.3)'; ctx.fillRect(left, top + CELL - 1, CELL, 1); }
      if (mask & 8) { ctx.fillStyle = `rgba(${rgb},0.1)`; ctx.fillRect(left, top, 2, CELL); }
      else { ctx.fillStyle = 'rgba(0,0,0,0.3)'; ctx.fillRect(left, top, 1, CELL); }
    }

    // --- Procedural flower drawing (5 shape types) ---
    function flowerHash(gx, gy) {
      let n = (gx * 73856093) ^ (gy * 19349663);
      n = ((n >> 16) ^ n) * 0x45d9f3b;
      n = ((n >> 16) ^ n) * 0x45d9f3b;
      return (n ^ (n >> 16)) >>> 0;
    }

    function drawProceduralFlower(cx, cy, gx, gy, player) {
      const s = ensureFlowerState(gx, gy, player);
      const now = performance.now() * 0.001;
      const idleSway = Math.sin(now * 1.5 + s.phase) * 0.06;
      const totalSway = idleSway + s.springDisp;
      const baseY = cy + CELL * 0.33;
      const stemLen = CELL * 0.5;
      const petalColor = player === P1 ? '#5bb9ff' : '#ffd240';
      const centerColor = player === P1 ? '#fff' : '#8B6914';
      const stemColor = '#3a8f3a';
      const type = s.type;

      ctx.save();
      ctx.translate(cx, baseY);
      ctx.rotate(totalSway);

      // Draw stem (shared by all types)
      ctx.strokeStyle = stemColor;
      ctx.lineWidth = 1.5;
      ctx.beginPath(); ctx.moveTo(0, 0); ctx.lineTo(0, -stemLen); ctx.stroke();

      if (type === 0) {
        // 5-petal round
        const pr = CELL * 0.12, pd = CELL * 0.09;
        ctx.fillStyle = petalColor;
        for (let i = 0; i < 5; i++) {
          const a = (i / 5) * Math.PI * 2 - Math.PI / 2;
          ctx.save();
          ctx.translate(Math.cos(a) * pd, -stemLen + Math.sin(a) * pd);
          ctx.rotate(a);
          ctx.beginPath(); ctx.ellipse(0, 0, pr, pr * 0.6, 0, 0, Math.PI * 2); ctx.fill();
          ctx.restore();
        }
        ctx.fillStyle = centerColor;
        ctx.beginPath(); ctx.arc(0, -stemLen, CELL * 0.05, 0, Math.PI * 2); ctx.fill();

      } else if (type === 1) {
        // 6-petal star (elongated pointed petals)
        const pr = CELL * 0.14, pd = CELL * 0.08;
        ctx.fillStyle = petalColor;
        for (let i = 0; i < 6; i++) {
          const a = (i / 6) * Math.PI * 2 - Math.PI / 2;
          ctx.save();
          ctx.translate(Math.cos(a) * pd, -stemLen + Math.sin(a) * pd);
          ctx.rotate(a);
          ctx.beginPath(); ctx.ellipse(0, 0, pr, pr * 0.3, 0, 0, Math.PI * 2); ctx.fill();
          ctx.restore();
        }
        ctx.fillStyle = centerColor;
        ctx.beginPath(); ctx.arc(0, -stemLen, CELL * 0.05, 0, Math.PI * 2); ctx.fill();

      } else if (type === 2) {
        // Daisy — 8 thin petals, small center
        const pr = CELL * 0.13, pd = CELL * 0.07;
        ctx.fillStyle = petalColor;
        for (let i = 0; i < 8; i++) {
          const a = (i / 8) * Math.PI * 2 - Math.PI / 2;
          ctx.save();
          ctx.translate(Math.cos(a) * pd, -stemLen + Math.sin(a) * pd);
          ctx.rotate(a);
          ctx.beginPath(); ctx.ellipse(0, 0, pr, pr * 0.25, 0, 0, Math.PI * 2); ctx.fill();
          ctx.restore();
        }
        ctx.fillStyle = centerColor;
        ctx.beginPath(); ctx.arc(0, -stemLen, CELL * 0.04, 0, Math.PI * 2); ctx.fill();

      } else if (type === 3) {
        // Tulip — 3 wide overlapping petals, cup shape
        ctx.fillStyle = petalColor;
        for (let i = 0; i < 3; i++) {
          const a = (i / 3) * Math.PI - Math.PI / 2;
          const ox = Math.cos(a) * CELL * 0.04;
          const oy = -stemLen + Math.sin(a) * CELL * 0.03 - CELL * 0.02;
          ctx.save();
          ctx.translate(ox, oy);
          ctx.rotate(a * 0.3);
          ctx.beginPath(); ctx.ellipse(0, 0, CELL * 0.09, CELL * 0.15, 0, 0, Math.PI * 2); ctx.fill();
          ctx.restore();
        }
        ctx.fillStyle = centerColor;
        ctx.beginPath(); ctx.arc(0, -stemLen, CELL * 0.03, 0, Math.PI * 2); ctx.fill();

      } else {
        // Cluster — 3 tiny flowers on branching stems
        const offsets = [
          { dx: -CELL * 0.08, dy: -stemLen * 0.95 },
          { dx:  CELL * 0.07, dy: -stemLen * 0.85 },
          { dx:  CELL * 0.01, dy: -stemLen * 1.05 }
        ];
        for (const o of offsets) {
          // branch stem
          ctx.strokeStyle = stemColor; ctx.lineWidth = 1;
          ctx.beginPath(); ctx.moveTo(0, -stemLen * 0.5); ctx.lineTo(o.dx, o.dy); ctx.stroke();
          // tiny flower
          ctx.fillStyle = petalColor;
          for (let i = 0; i < 4; i++) {
            const a = (i / 4) * Math.PI * 2;
            ctx.beginPath();
            ctx.ellipse(o.dx + Math.cos(a) * CELL * 0.03, o.dy + Math.sin(a) * CELL * 0.03,
                        CELL * 0.04, CELL * 0.025, a, 0, Math.PI * 2);
            ctx.fill();
          }
          ctx.fillStyle = centerColor;
          ctx.beginPath(); ctx.arc(o.dx, o.dy, CELL * 0.02, 0, Math.PI * 2); ctx.fill();
        }
      }

      ctx.restore();
    }

    // --- Walking character helpers ---
    function spawnWalker(player, gx, gy) {
      const targetX = ORIGIN_X + gx * CELL + CELL / 2;
      const targetY = ORIGIN_Y + gy * CELL + CELL / 2;
      let startX, startY;
      if (player === P1) { startX = ORIGIN_X + GRID * CELL; startY = ORIGIN_Y + GRID * CELL; }
      else { startX = ORIGIN_X + GRID * CELL; startY = ORIGIN_Y; }
      walkers.push({ player, startX, startY, targetX, targetY, progress: 0, speed: 4, gx, gy });
    }

    function updateWalkers(dt) {
      for (let i = walkers.length - 1; i >= 0; i--) {
        walkers[i].progress += walkers[i].speed * dt;
        if (walkers[i].progress >= 1) walkers.splice(i, 1);
      }
    }

    function drawWalker(w) {
      const t = Math.min(1, w.progress);
      const ease = t < 0.5 ? 2 * t * t : 1 - Math.pow(-2 * t + 2, 2) / 2;
      const x = w.startX + (w.targetX - w.startX) * ease;
      const y = w.startY + (w.targetY - w.startY) * ease;
      const phase = t * Math.PI * 8;
      const bob = Math.sin(phase) * 1.5;
      const legSwing = Math.sin(phase) * 3;
      const color = w.player === P1 ? '#5bb9ff' : '#ffd240';
      ctx.save();
      ctx.translate(x, y + bob);
      // Legs
      ctx.strokeStyle = color; ctx.lineWidth = 1;
      ctx.beginPath(); ctx.moveTo(-1, 3); ctx.lineTo(-1 - legSwing, 7); ctx.moveTo(1, 3); ctx.lineTo(1 + legSwing, 7); ctx.stroke();
      // Body
      ctx.fillStyle = color; ctx.fillRect(-2, -4, 4, 7);
      // Head
      ctx.fillRect(-2, -7, 4, 3);
      ctx.restore();
    }

    function drawAllWalkers() { for (const w of walkers) drawWalker(w); }

    // Drawing helpers ------------------------------------------------------
    function seededChoice(x,y){ return ((x*73856093) ^ (y*19349663)) & 1; }

    function drawCellBackground(x, y){
      const left = ORIGIN_X + x * CELL;
      const top  = ORIGIN_Y + y * CELL;
      if (PROCEDURAL_FLOWERS) {
        // Black bg + procedural grass blades
        ctx.fillStyle = '#000000';
        ctx.fillRect(left, top, CELL, CELL);
        let seed = ensureGrassState(x, y);
        const nextSeed = () => { seed = (seed * 1103515245 + 12345) >>> 0; return seed; };
        const bladeCount = 4 + (nextSeed() % 5); // 4-8 blades
        for (let i = 0; i < bladeCount; i++) {
          const bx = left + 2 + (nextSeed() % (CELL - 4));
          const by = top + 4 + (nextSeed() % (CELL - 6)); // scattered vertically
          const bh = 3 + (nextSeed() % 4); // 3-6px tall
          const lean = ((nextSeed() % 5) - 2) * 0.15; // slight lean
          const green = 0x1a + (nextSeed() % 0x11); // 0x1a..0x2a
          ctx.strokeStyle = `rgb(${green >> 1},${green},${green >> 1})`;
          ctx.lineWidth = 1;
          ctx.beginPath();
          ctx.moveTo(bx, by);
          ctx.lineTo(bx + lean * bh, by - bh);
          ctx.stroke();
        }
      } else {
        const cx = left + Math.floor(CELL/2);
        const cy = top  + Math.floor(CELL/2);
        if (Sprites.isReady()){
          const base = Sprites.get('iso_tile');
          const scale = base ? (CELL / base.fw) : 1;
          Sprites.draw('iso_tile', cx, cy, { center: true, scale });
        } else {
          ctx.fillStyle = '#000000'; ctx.fillRect(left, top, CELL, CELL);
        }
      }
    }

    function drawBlueFlower(cx, cy, r, gx, gy){
      if (PROCEDURAL_FLOWERS && gx !== undefined) { drawProceduralFlower(cx, cy, gx, gy, P1); return; }
      if (Sprites.isReady()){
        const sh = Sprites.get('flower_blue');
        const scale = sh ? (CELL / sh.fw) : 1;
        Sprites.draw('flower_blue', cx, cy, { center: true, scale, anim: 'idle' });
      } else {
        ctx.fillStyle = '#5bb9ff';
        ctx.beginPath(); ctx.arc(cx, cy, Math.max(6, CELL*0.45), 0, Math.PI*2); ctx.fill();
      }
    }

    function drawYellowFlower(cx, cy, r, gx, gy){
      if (PROCEDURAL_FLOWERS && gx !== undefined) { drawProceduralFlower(cx, cy, gx, gy, P2); return; }
      if (Sprites.isReady()){
        const sh = Sprites.get('flower_yellow');
        const scale = sh ? (CELL / sh.fw) : 1;
        Sprites.draw('flower_yellow', cx, cy, { center: true, scale, anim: 'idle' });
      } else {
        ctx.fillStyle = '#ffd240';
        ctx.beginPath(); ctx.arc(cx, cy, Math.max(6, CELL*0.45), 0, Math.PI*2); ctx.fill();
      }
    }

    function drawArrowCell(cx, cy, type, arrowScale){
      const x = cx*CELL, y = cy*CELL, w = CELL, h = CELL;
      ctx.fillStyle = '#000000';
      ctx.fillRect(x, y, w, h);
      let rot = 0;
      if (type === 'row-left') rot = Math.PI;
      if (type === 'row-right') rot = 0;
      if (type === 'col-up') rot = -Math.PI/2;
      if (type === 'col-down') rot = Math.PI/2;
      const s = arrowScale || 0.5;
      ctx.save();
      ctx.translate(x + w/2, y + h/2); ctx.rotate(rot);
      ctx.scale(s, s);
      ctx.fillStyle = getArrowColor();
      ctx.beginPath();
      ctx.moveTo(-w*0.28, -h*0.34);
      ctx.lineTo(w*0.36, 0);
      ctx.lineTo(-w*0.28, h*0.34);
      ctx.closePath(); ctx.fill();
      ctx.restore();
    }

    const TINT_P1 = 'rgba(64,180,255,1)';
    const TINT_P2 = 'rgba(255,210,64,1)';
    function getArrowColor(){ return current === P1 ? '#40b4ff' : '#ffd240'; }

    // ===== Sprite system =====
    // Replace the src paths below with your own sprite sheets
    const ASSET_SPECS = {
      // Using GitHub raw URLs at the provided commit. Change only the filenames if different.
      iso_tile:     { src: 'https://raw.githubusercontent.com/orac808/tictacten/a8c7857ee8e66718c37b91ad019fe300969c01a4/sprites/iso_tile.png', fw: 32, fh: 32, frames: 1 },
      arrow_white:  { src: 'https://raw.githubusercontent.com/orac808/tictacten/a8c7857ee8e66718c37b91ad019fe300969c01a4/sprites/arrow_white_sheet.png', fw: 32, fh: 32, frames: 4, anims: { idle: { frames: [0,1,2,3], fps: 8 } } },
      flower_blue:  { src: 'https://raw.githubusercontent.com/orac808/tictacten/a8c7857ee8e66718c37b91ad019fe300969c01a4/sprites/flower_blue_sheet.png',  fw: 32, fh: 32, frames: 6, anims: { idle: { frames: [0,1,2,3,4,5], fps: 6 }, win: { frames: [0,2,4,5], fps: 10 } } },
      flower_yellow:{ src: 'https://raw.githubusercontent.com/orac808/tictacten/a8c7857ee8e66718c37b91ad019fe300969c01a4/sprites/flower_yellow_sheet.png', fw: 32, fh: 32, frames: 6, anims: { idle: { frames: [0,1,2,3,4,5], fps: 6 }, win: { frames: [0,2,4,5], fps: 10 } } }
    };

    const Sprites = (()=>{
      const sheets = new Map();
      let ready = false;
      function loadOne(key, spec){
        return new Promise((res, rej)=>{
          const img = new Image(); img.crossOrigin = 'anonymous';
          img.onload = ()=>{ sheets.set(key, { img, ...spec }); console.info(`[sprites] loaded ${key}`, {w:img.width, h:img.height, spec}); res(); };
          img.onerror = rej; img.src = spec.src;
        });
      }
      async function loadAll(){
        const keys = Object.keys(ASSET_SPECS);
        if (keys.length===0){ ready = true; return; }
        await Promise.all(keys.map(k=>loadOne(k, ASSET_SPECS[k])));
        ready = true;
      }
      function isReady(){ return ready; }
      function get(key){ return sheets.get(key); }
      function draw(key, x, y, opts={}){
        const s = sheets.get(key); if (!s || !isFinite(x) || !isFinite(y)) return;
        const time = performance.now() * 0.001;
        const anim = opts.anim && s.anims && s.anims[opts.anim] ? s.anims[opts.anim] : (s.anims && s.anims.idle) ? s.anims.idle : null;
        let frame = isFinite(opts.frame) ? opts.frame|0 : 0;
        if (anim){ const idx = Math.floor(time * (anim.fps||8)) % anim.frames.length; frame = anim.frames[idx]; }
        const cols = Math.max(1, Math.floor(s.img.width / s.fw));
        const sx = (frame % cols) * s.fw;
        const sy = Math.floor(frame / cols) * s.fh;
        const scale = (opts.scale && opts.scale>0) ? opts.scale : 1;
        const dx = opts.center ? x - s.fw*scale/2 : x;
        const dy = opts.center ? y - s.fh*scale/2 : y;
        const rw = s.fw*scale, rh = s.fh*scale;
        if (opts.rotate){ ctx.save(); ctx.translate(x, y); ctx.rotate(opts.rotate); ctx.translate(-x, -y); }
        if (opts.tint){
          const tw = Math.ceil(rw), th = Math.ceil(rh);
          const oc = document.createElement('canvas'); oc.width = tw; oc.height = th; const octx = oc.getContext('2d');
          octx.imageSmoothingEnabled = false;
          octx.drawImage(s.img, sx, sy, s.fw, s.fh, 0, 0, tw, th);
          octx.globalCompositeOperation = 'source-atop';
          octx.fillStyle = opts.tint; octx.fillRect(0,0,tw,th);
          ctx.drawImage(oc, dx, dy);
        } else {
          ctx.imageSmoothingEnabled = false;
          ctx.drawImage(s.img, sx, sy, s.fw, s.fh, dx, dy, rw, rh);
        }
        if (opts.rotate){ ctx.restore(); }
      }
      loadAll();
      return { isReady, get, draw };
    })();

    function draw(){
      // clear whole 11x11
      ctx.fillStyle = '#000000';
      ctx.fillRect(0, 0, TOTAL*CELL, TOTAL*CELL);

      // gutters
      for (let r=0;r<GRID;r++){
        if (!isSlideForbidden('row', r)) {
          drawArrowCell(0, GUTTER + r, 'row-left', ensureArrowSpring(0, GUTTER + r).scale);
          drawArrowCell(TOTAL-1, GUTTER + r, 'row-right', ensureArrowSpring(TOTAL-1, GUTTER + r).scale);
        }
      }
      for (let c=0;c<GRID;c++){
        if (!isSlideForbidden('col', c)) {
          drawArrowCell(GUTTER + c, 0, 'col-up', ensureArrowSpring(GUTTER + c, 0).scale);
          drawArrowCell(GUTTER + c, TOTAL-1, 'col-down', ensureArrowSpring(GUTTER + c, TOTAL-1).scale);
        }
      }

      // ground: skip animating row/col here, they will be drawn separately
      for (let y=0;y<GRID;y++){
        if (anim && anim.kind==='row' && y===anim.idx) continue;
        for (let x=0;x<GRID;x++){
          if (anim && anim.kind==='col' && x===anim.idx) continue;
          drawCellBackground(x,y);
        }
      }

      // ownership tint per 3x3 with fade alphas
      for (let by=0; by<3; by++){
        for (let bx=0; bx<3; bx++){
          const f = blockFade[by][bx];
          if (f.a1>0){ ctx.globalAlpha = 0.45 * f.a1; ctx.fillStyle = TINT_P1; ctx.fillRect(ORIGIN_X + bx*3*CELL, ORIGIN_Y + by*3*CELL, 3*CELL, 3*CELL); }
          if (f.a2>0){ ctx.globalAlpha = 0.45 * f.a2; ctx.fillStyle = TINT_P2; ctx.fillRect(ORIGIN_X + bx*3*CELL, ORIGIN_Y + by*3*CELL, 3*CELL, 3*CELL); }
          ctx.globalAlpha = 1;
        }
      }

      // cell grid lines (1px dotted) — pixel-snap with 0.5 translate
      ctx.save();
      ctx.translate(0.5, 0.5);
      ctx.globalAlpha = 1;
      ctx.strokeStyle = '#1a3a1a';
      ctx.lineWidth = 1;
      ctx.setLineDash([2, 4]);
      for (let i = 1; i < GRID; i++) {
        // skip lines that fall on mini-board borders (every 3rd)
        if (i % 3 === 0) continue;
        const hx = ORIGIN_X + i * CELL;
        ctx.beginPath(); ctx.moveTo(hx, ORIGIN_Y); ctx.lineTo(hx, ORIGIN_Y + GRID * CELL); ctx.stroke();
        const hy = ORIGIN_Y + i * CELL;
        ctx.beginPath(); ctx.moveTo(ORIGIN_X, hy); ctx.lineTo(ORIGIN_X + GRID * CELL, hy); ctx.stroke();
      }
      ctx.setLineDash([]);
      ctx.restore();

      // mini board borders (dark green) — drawn at integer coords for crisp 2px lines
      ctx.strokeStyle = '#2a5a2a';
      ctx.lineWidth = 2;
      for (let by = 0; by < 3; by++){
        for (let bx = 0; bx < 3; bx++){
          ctx.strokeRect(ORIGIN_X + bx*3*CELL, ORIGIN_Y + by*3*CELL, 3*CELL, 3*CELL);
        }
      }

      // pieces excluding anim row/col
      for (let y=0; y<GRID; y++){
        if (anim && anim.kind==='row' && y===anim.idx) continue;
        for (let x=0; x<GRID; x++){
          if (anim && anim.kind==='col' && x===anim.idx) continue;
          const v = board[y][x]; if (!v) continue;
          const cx = ORIGIN_X + x*CELL + Math.floor(CELL/2);
          const cy = ORIGIN_Y + y*CELL + Math.floor(CELL/2);
          if (v === P1) drawBlueFlower(cx, cy, Math.floor(CELL*0.50), x, y);
          if (v === P2) drawYellowFlower(cx, cy, Math.floor(CELL*0.42), x, y);
        }
      }

      // animated overlay for row/col
      if (anim){
        if (anim.kind==='row') drawAnimatingRow(anim);
        else drawAnimatingCol(anim);
      }

      // Walking characters
      if (SHOW_WALKERS) drawAllWalkers();
    }

    function wrapIndex(i, n){ return (i % n + n) % n; }

    function drawAnimatingRow(a){
      const r = a.idx; const dir = a.dir; const t = a.t; const shift = dir * t * CELL;
      const yTop = ORIGIN_Y + r*CELL;
      ctx.save();
      ctx.beginPath(); ctx.rect(ORIGIN_X, yTop, GRID*CELL, CELL); ctx.clip();
      // draw backgrounds and pieces for columns -1..GRID to cover wrap
      for (let k=-1; k<=GRID; k++){
        const srcIndex = wrapIndex(k, GRID);
        const px = ORIGIN_X + k*CELL + shift;
        // draw background tile translated to px
        ctx.save();
        ctx.translate(px - (ORIGIN_X + srcIndex*CELL), 0);
        drawCellBackground(srcIndex, r);
        const v = a.pre[srcIndex];
        if (v){
          const cx = ORIGIN_X + srcIndex*CELL + Math.floor(CELL/2);
          const cy = ORIGIN_Y + r*CELL + Math.floor(CELL/2);
          if (v === P1) drawBlueFlower(cx, cy, Math.floor(CELL*0.50), srcIndex, r);
          if (v === P2) drawYellowFlower(cx, cy, Math.floor(CELL*0.42), srcIndex, r);
        }
        ctx.restore();
      }
      ctx.restore();
    }

    function drawAnimatingCol(a){
      const c = a.idx; const dir = a.dir; const t = a.t; const shift = dir * t * CELL;
      ctx.save();
      ctx.beginPath(); ctx.rect(ORIGIN_X + c*CELL, ORIGIN_Y, CELL, GRID*CELL); ctx.clip();
      for (let k=-1; k<=GRID; k++){
        const srcIndex = wrapIndex(k, GRID);
        const py = ORIGIN_Y + k*CELL + shift;
        ctx.save();
        ctx.translate(0, py - (ORIGIN_Y + srcIndex*CELL));
        drawCellBackground(c, srcIndex);
        const v = a.pre[srcIndex];
        if (v){
          const cx = ORIGIN_X + c*CELL + Math.floor(CELL/2);
          const cy = ORIGIN_Y + srcIndex*CELL + Math.floor(CELL/2);
          if (v === P1) drawBlueFlower(cx, cy, Math.floor(CELL*0.50), c, srcIndex);
          if (v === P2) drawYellowFlower(cx, cy, Math.floor(CELL*0.42), c, srcIndex);
        }
        ctx.restore();
      }
      ctx.restore();
    }

    function drawMetaPreview(){
      const size = metaCanvas.width / DPR;
      mctx.clearRect(0,0,size,size);
      mctx.fillStyle = '#0a0a0a'; mctx.fillRect(0,0,size,size);
      mctx.strokeStyle = '#31353d'; mctx.lineWidth = 1;
      for (let i=1;i<3;i++){
        const t = i*size/3;
        mctx.beginPath(); mctx.moveTo(0,t); mctx.lineTo(size,t); mctx.stroke();
        mctx.beginPath(); mctx.moveTo(t,0); mctx.lineTo(t,size); mctx.stroke();
      }
      for (let by=0; by<3; by++){
        for (let bx=0; bx<3; bx++){
          const owner = smallOwner(bx, by); if (!owner) continue;
          const cx = bx*size/3 + size/6; const cy = by*size/3 + size/6;
          // tiny glyphs
          if (owner===P1){ mctx.fillStyle = '#5bb9ff'; mctx.fillRect(cx-2, cy-3, 4, 6); }
          else { mctx.fillStyle = '#ffd33b'; mctx.fillRect(cx-3, cy-2, 6, 4); }
        }
      }
      const w = metaWinner();
      if (w){
        mctx.strokeStyle = w===P1 ? '#40b4ff' : '#ffd240';
        mctx.lineWidth = 4; mctx.strokeRect(2,2,size-4,size-4);
      }
    }

    // ===== Win celebration overlay with flower particles =====
    const BLUE_PALETTE = ['#5bb9ff','#40a0ff','#7ec8ff','#3d8fd4','#90d0ff'];
    const YELLOW_PALETTE = ['#ffd240','#ffb820','#ffe070','#d4a520','#ffdc60'];
    let winParticles = [];
    let winAnimRunning = false;
    let winBgAlpha = 0;

    function createFlowerParticle(palette){
      const w = innerWidth, h = innerHeight;
      return {
        x: Math.random() * w,
        y: -20 - Math.random() * h * 0.5,
        size: 10 + Math.random() * 22,
        color: palette[Math.floor(Math.random() * palette.length)],
        vy: 40 + Math.random() * 60,
        vx: (Math.random() - 0.5) * 30,
        swayAmp: 15 + Math.random() * 25,
        swaySpeed: 0.8 + Math.random() * 1.2,
        swayOffset: Math.random() * Math.PI * 2,
        rotation: Math.random() * Math.PI * 2,
        rotSpeed: (Math.random() - 0.5) * 2,
        petals: 5,
        alpha: 0.7 + Math.random() * 0.3,
        time: 0
      };
    }

    function drawFlower(fctx, p){
      fctx.save();
      fctx.translate(p.x, p.y);
      fctx.rotate(p.rotation);
      fctx.globalAlpha = p.alpha;
      fctx.fillStyle = p.color;
      const r = p.size / 2;
      const petalR = r * 0.55;
      for (let i = 0; i < p.petals; i++){
        const angle = (i / p.petals) * Math.PI * 2;
        const px = Math.cos(angle) * r * 0.45;
        const py = Math.sin(angle) * r * 0.45;
        fctx.beginPath();
        fctx.ellipse(px, py, petalR, petalR * 0.65, angle, 0, Math.PI * 2);
        fctx.fill();
      }
      // center
      fctx.globalAlpha = p.alpha * 0.9;
      fctx.fillStyle = '#fff';
      fctx.beginPath();
      fctx.arc(0, 0, r * 0.2, 0, Math.PI * 2);
      fctx.fill();
      fctx.restore();
    }

    function updateFlowerParticle(p, dt){
      p.time += dt;
      p.y += p.vy * dt;
      p.x += p.vx * dt + Math.sin(p.time * p.swaySpeed + p.swayOffset) * p.swayAmp * dt;
      p.rotation += p.rotSpeed * dt;
    }

    function showWinOverlay(w){
      if (winAnimRunning) return;
      const isBlue = w === P1;
      const palette = isBlue ? BLUE_PALETTE : YELLOW_PALETTE;
      const color = isBlue ? '#5bb9ff' : '#ffd240';

      winText.textContent = isBlue ? 'Blue Wins!' : 'Yellow Wins!';
      winText.style.color = color;
      winPlayAgain.style.color = color;
      winPlayAgain.style.borderColor = color;

      // Resize win canvas
      winCanvas.width = innerWidth * DPR;
      winCanvas.height = innerHeight * DPR;
      winCanvas.style.width = innerWidth + 'px';
      winCanvas.style.height = innerHeight + 'px';
      winCtx.setTransform(DPR, 0, 0, DPR, 0, 0);

      // Create particles
      winParticles = [];
      for (let i = 0; i < 50; i++){
        winParticles.push(createFlowerParticle(palette));
      }

      winBgAlpha = 0;
      winAnimRunning = true;
      Sound.play('win'); Sound.duckMusic();
      winOverlay.classList.add('show');
      winMsg.classList.remove('visible');

      // Fade in message after a beat
      setTimeout(() => { winMsg.classList.add('visible'); }, 500);

      // Hide turn indicator during win
      turnIndicator.style.opacity = '0';
    }

    function hideWinOverlay(){
      winAnimRunning = false;
      winParticles = [];
      winOverlay.classList.remove('show');
      winMsg.classList.remove('visible');
      winCtx.clearRect(0, 0, innerWidth, innerHeight);
    }

    function drawWinFrame(dt){
      if (!winAnimRunning) return;
      const w = innerWidth, h = innerHeight;
      winCtx.clearRect(0, 0, w, h);

      // Fade in background
      if (winBgAlpha < 0.65) winBgAlpha = Math.min(0.65, winBgAlpha + dt * 1.5);
      winCtx.fillStyle = `rgba(0,0,0,${winBgAlpha})`;
      winCtx.fillRect(0, 0, w, h);

      // Update and draw particles
      for (let i = winParticles.length - 1; i >= 0; i--){
        const p = winParticles[i];
        updateFlowerParticle(p, dt);
        drawFlower(winCtx, p);
        // Recycle particles that go off bottom
        if (p.y > h + 40){
          p.y = -20 - Math.random() * 40;
          p.x = Math.random() * w;
          p.time = 0;
        }
      }
    }

    winPlayAgain.addEventListener('click', () => { reset(); });

    // Menu controls
    function toggleMenu(force){
      const wantOpen = typeof force === 'boolean' ? force : !menu.classList.contains('open');
      if (wantOpen) menu.classList.add('open'); else menu.classList.remove('open');
    }
    openBtn.addEventListener('click', () => toggleMenu());
    closeBtn.addEventListener('click', () => toggleMenu(false));
    menu.addEventListener('click', e => { if (e.target === menu) toggleMenu(false); });

    // Init
    function init(){
      if (window.__booted) return; window.__booted = true;
      reset(); resize(); requestAnimationFrame(frame);
    }
    init();

    // Self-tests
    (function tests(){
      try {
        console.groupCollapsed('Self-tests');
        const empty = () => Array.from({length:GRID}, () => Array(GRID).fill(EMPTY));
        { const b = empty(); console.assert(smallOwnerFrom(b,0,0)===EMPTY, 'T1 smallOwner empty'); console.assert(metaWinnerFrom(b)===EMPTY, 'T1 meta empty'); }
        { const b = empty(); for (let x=0;x<3;x++) b[0][x] = P1; for (let y=0;y<3;y++) b[y][1] = P1; console.assert(smallOwnerFrom(b,0,0)===P1, 'T2 owner P1'); }
        { const b = empty(); for (let bx=0; bx<3; bx++){ const sx = bx*3; const sy = 0; for (let x=0; x<3; x++) b[sy][sx+x] = P1; } console.assert(metaWinnerFrom(b)===P1, 'T3 meta P1 top row'); }
        { const bad = [[1,2,3]]; console.assert(smallOwnerFrom(bad,0,0)===EMPTY, 'T4 malformed safe'); }
        // New: row and col animation commit produces same result as instant slide
        { const b = empty(); b[0] = [1,2,3,4,5,6,7,8,9];
          const instant = b[0].slice(); const last = instant[8]; for (let c=8;c>0;c--) instant[c]=instant[c-1]; instant[0]=last;
          // simulate post for anim logic
          const pre = [1,2,3,4,5,6,7,8,9]; const post = pre.slice(); const last2 = post[8]; for (let c=8;c>0;c--) post[c]=post[c-1]; post[0]=last2;
          console.assert(JSON.stringify(instant)===JSON.stringify(post), 'T5 animated row matches instant');
        }
        console.groupEnd();
      } catch(e){ console.error('Self-tests error', e); }
    })();
</script>
<script>
// ---- Safety & boot shims ----
(function(){
  // Provide seededChoice if missing
  if (typeof window.seededChoice !== 'function'){
    window.seededChoice = function(x,y){
      // simple deterministic hash 0/1
      let n = (x*73856093) ^ (y*19349663);
      n = (n<<13) ^ n; n = (n*(n*n*15731 + 789221) + 1376312589) & 0x7fffffff;
      return n & 1;
    };
  }

  // Arrow colour helper if missing
  if (typeof window.getArrowColor !== 'function'){
    window.getArrowColor = function(){
      try{ return (typeof current !== 'undefined' && typeof P1 !== 'undefined' && current === P1) ? '#40b4ff' : '#ffd240'; }
      catch(e){ return '#ffffff'; }
    };
  }

  // Init wiring
  function safeInit(){
    if (typeof init === 'function') { try { init(); } catch(e){ reportError(e); } }
  }
  if (document.readyState === 'loading'){
    window.addEventListener('DOMContentLoaded', safeInit);
  } else { safeInit(); }

  // Error overlay on the canvas so blank screens show a reason
  function reportError(e){
    try{
      const cvs = document.querySelector('canvas');
      if (!cvs) return;
      const c = cvs.getContext('2d');
      c.save(); c.reset && c.reset();
      c.fillStyle = '#111'; c.fillRect(0,0,cvs.width,cvs.height);
      c.fillStyle = '#f55'; c.font = '16px ui-monospace, SFMono-Regular, Menlo, monospace';
      const msg = (e && e.stack) ? e.stack : String(e);
      const lines = msg.split('\n').slice(0,10);
      c.fillText('Runtime error:', 16, 28);
      lines.forEach((ln,i)=>c.fillText(ln, 16, 60 + i*20));
      c.restore();
      console.error(e);
    }catch(_){}
  }
  window.addEventListener('error', ev=>{ reportError(ev.error || ev.message); });
})();
</script>
</body>
</html>
